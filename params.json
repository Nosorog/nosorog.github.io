{
  "name": "Nosorog",
  "tagline": "CDI injections for server-side JavaScript (and more)",
  "body": "*Disclaimer: this is a WIP. Please refer to the corresponding Wiki pages to check for feature completeness.*\r\n\r\n* nosorog-core: [GitHub](https://github.com/Nosorog/nosorog-core), [status](https://github.com/Nosorog/nosorog-core/wiki/Status)\r\n\r\n# Preface\r\n\r\nFor Java EE developers, JavaScript has been around for years. Introduced in 2012, Nashorn is a modern and performant JavaScript engine for JVM. JavaScript is a perfect candidate for being first-class citizen of the Java EE ecosystem. What prevents it from being one is lack of seamless integration with Java EE platform and application components - something similar to what CDI does for Java EE applications.\r\n\r\nThe goal of the project is to provide such an integration, together with several other productivity features.\r\n\r\n# Examples\r\n\r\nPrint a banner upon application startup. It is assumed that the `@Default Configuration` bean is provided by the application:\r\n\r\n```javascript\r\n// Using JSDoc semantics\r\n/**\r\n * import org.apache.commons.configuration.Configuration\r\n * import java.util.logging.Level\r\n *\r\n * @Startup(order = 1)\r\n * @Inject Configuration config\r\n*/\r\n\r\n$LOG.log(Level.INFO, \"Starting MyApplication {0} b{1}\", [\r\n        config.getString(\"myapp.version\"),\r\n        config.getString(\"myapp.build\")\r\n    ]);\r\n```\r\n\r\nRun FlyWay migrations:\r\n\r\n```javascript\r\n// Using prologue directives\r\n\"import javax.sql.DataSource\";\r\n\"import org.flywaydb.core.Flyway\";\r\n\r\n\"@Startup(order = 2)\";\r\n\"@Resource(lookup = \"jdbc/MyDB\") DataSource ds\";\r\n\r\nvar flyway = new Flyway();\r\nflyway.setDataSource(ds);\r\nflyway.setBaselineOnMigrate(true);\r\nflyway.migrate();\r\n```\r\n\r\nDo periodic housekeeping:\r\n\r\n```javascript\r\n/**\r\n * @Name(\"Housekeeping\")\r\n * @Description(\"Do some housekeeping once a day\")\r\n * @Schedule(\"02 4 * * *\")\r\n *\r\n * import my.package.HouseKeeping\r\n *\r\n * @Inject HouseKeeping task\r\n*/\r\n\r\ntask.run();\r\n```\r\n\r\nLog HTTP session creation:\r\n\r\n```javascript\r\n/**\r\n * @Name(\"SessionLog\")\r\n * @Observes @Initialized(SessionScoped.class) HttpSession session\r\n *\r\n * import my.package.log.HTTPSessionLogRecord\r\n * import javax.persistence.EntityManager\r\n * import javax.transaction.UserTransaction\r\n * \r\n * @PersistenceContext EntityManager em\r\n * @Resource UserTransaction tx\r\n*/\r\n\r\ntx.begin();\r\nvar record = new HTTPSessionLogRecord(session);\r\nem.persist(record);\r\ntx.commit();\r\n```\r\n\r\n# Features\r\n\r\n## CDI Support\r\n\r\nIn addition to `@Inject`, the following Java EE resource injections are supported:\r\n* `@Resource`\r\n* `@EJB`\r\n* `@PersistenceUnit` / `@PersistenceContext`\r\n* `@WebServiceRef`\r\n\r\nThe syntax generally mirrors that of Java code. Injections are defined inside a script header, JSDoc-style.\r\n\r\n## Execution Modes\r\n\r\nScripts can be invoked in the following ways:\r\n\r\n1. Programmatic (using Java or REST APIs)\r\n2. Interactive (using web console or IDE plugin)\r\n3. On startup (using the `@Startup` annotation)\r\n4. Scheduled/periodic (using the `@Schedule` annotation)\r\n5. Triggered by CDI event (using the `@Observes` annotation)\r\n \r\n## Script Libraries\r\n\r\nThe runtime will look for scripts in the following sources:\r\n* Application library: a read-only script collection that is packaged and deployed together with the application\r\n* User library: a read-write collection that resides in a filesystem.\r\n\r\n## Miscellaneous\r\n\r\n### Imports\r\n\r\nA typical server-side script usually begins with a number of surrogate \"imports\" like this:\r\n\r\n```javascript\r\nvar Foo = my.package.Foo;\r\nvar Bar = my.package.Bar;\r\nvar Configuration = org.apache.commons.configuration.Configuration;\r\nvar Level = java.util.logging.Level;\r\n...\r\nvar foo = new Foo();\r\n```\r\n\r\nNow one can easily get rid of such a surrogates by using `import` directives in a script header. Wildcards and static imports are supported.\r\n\r\n### Logging\r\n\r\nThe runtime provides an implicit `$LOG` variable that is initialized with a `java.util.logging.Logger` instance. The logger name is composed of a common prefix + (unique) script name.\r\n\r\n# Use cases\r\n\r\n## Application startup\r\n\r\nA typical Java EE application's initialization process is usually comprised of the following steps:\r\n\r\n1. Print a banner with application name, version and build ID/timestamp;\r\n2. Run Flyway/LiquiBase migrations;\r\n3. Generate test data (if on a dev or QA box);\r\n4. Read and validate configuration;\r\n5. Create working directories if they do not exist;\r\n6. Set up logging system (e.g., instruct JUL to use custom log directory);\r\n7. Configure JAX-RS multipart handling;\r\n8. etc.\r\n\r\nNearly all of these could be implemented as scripts, with the clear execution order and ability to enable/disable some of them without recompilation/redeployment. For example, a developer might intentionally disable database migrations on his box.\r\n\r\nGenerating test data is a particular use case. Modern development approaches assume rapidly changing schema and/or using NoSQL databases. In such cases, generating test data from application code is much more convenient than shipping tons of pre-generated SQL or JSON data. Additionally, test data parameteres could be changed on the fly, without application recompilation. Producing a completely different test data set would be as simlpe as tweaking a script and reloading your application.\r\n\r\n## Developer productivity\r\n\r\nReal-life data is usually orders of magnitude more complex than any test data imaginable.\r\n\r\nSimply open web console on a live application and:\r\n\r\n* isolate a bug that manifests in production only, without connecting debugger to application server and without suspending application threads;\r\n* see how a particular JPQL query performs on live data;\r\n* try new data processing algorithms and other ideas;\r\n* etc.\r\n \r\nOf course running arbitrary code on a production system is a double-edged sword. One should fully realize the risks of potentially corrupting production data by running untested code.\r\n\r\n## Maintenance & Monitoring\r\n\r\nIf you need to quickly provide application specific metrics, and consider JMX a sledge-hammer, you can use server-side scripts as a poor man's alternative. Similarly, if there are some maintenance tasks to be done on occasion, implement them as scripts, so even a non-programmer could invoke them simply by selecting from a list.\r\n\r\n## Fluid Logic\r\n\r\nThe Fluid Logic pattern is described in Adam Bien's [Real World Java EE Patterns](http://realworldpatterns.com) book:\r\n\r\n> Java is a static language with emphasis on its strong typing. Java is well suitable for the implementation\r\nof well-defned, stable business logic. Algorithms that often change require recompilation and even\r\nredeployment of the whole application.\r\n\r\n> Strong typing and the static nature of Java are features and drawbacks at the same time. For integration\r\npurposes, dynamic languages such as JavaScript, Ruby, or Python are better suitable and more effcient.\r\nWith Java it is hardly possible to evaluate or interpret business logic at runtime.\r\n\r\nWith CDI injections available, Fluid Logic can be implemented in a more natural way and with less boilerplate code. All the considerations on testing, performance, security and robustness apply; refer to the corresponding book chapter for further info.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}